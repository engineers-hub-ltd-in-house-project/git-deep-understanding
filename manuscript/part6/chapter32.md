# 第 6 部: Git の便利な道具箱

---

# 第 32 章: よくある Git のエラーと解決策

Git を使っていると、様々なエラーメッセージに遭遇します。これらは初心者を混乱させることがありますが、そのほとんどは Git がリポジトリの整合性を保つための親切な警告であり、原因と意味を理解すれば怖くありません。

この章では、開発現場で頻繁に遭遇する代表的なエラーと、その原因、そして安全な解決策を解説します。

---
## 32.1 `detached HEAD` state

- **エラーメッセージ**: `You are in 'detached HEAD' state.`
- **状況**: `git switch <commit-hash>` や `git switch <tag-name>` のように、ブランチ名以外のものをチェックアウトしたときに発生します。
- **原因**: `HEAD` が特定のブランチを指すのではなく、歴史の中の一つのコミットを**直接指している**状態です。これは、過去の特定の時点のコードを一時的に確認するための「読み取り専用」モードのようなものです。
- **問題点**: この状態で新しいコミットを作成すると、そのコミットはどのブランチにも属さないため、後で別のブランチに切り替えた瞬間に見失ってしまいます (いずれガベージコレクションで削除されます)。
- **解決策**:
    - **単に過去のコードを確認したかっただけの場合**: `git switch <branch-name>` (例: `git switch main`) を実行して、通常のブランチに戻れば OK です。
    - **この時点から新しい作業を始めたい場合**: `git switch -c <new-branch-name>` を実行します。これにより、現在の `HEAD` が指すコミットを起点とした新しいブランチが作成され、`detached HEAD` 状態は解消されます。

---
## 32.2 `non-fast-forward` (Push rejected)

- **エラーメッセージ**: `! [rejected] main -> main (non-fast-forward)`
- **状況**: `git push` を実行したとき。
- **原因**: Part5 で学んだ通り、あなたのローカルリポジトリがリモートリポジトリの最新の状態を反映していないことが原因です。あなたが最後に `fetch` (または `pull`) してから、他の誰かが同じブランチに新しいコミットを `push` したため、歴史が分岐しています。Git は、リモートのコミットが失われる可能性のある `push` を安全のために拒否します。
- **解決策**:
    1.  `git fetch origin` を実行して、リモートの最新の変更をリモート追跡ブランチ (`origin/main`) に取り込みます。
    2.  `git log main..origin/main` で、どのような変更があったかを確認します。
    3.  `git merge origin/main` または `git rebase origin/main` を使って、リモートの変更をローカルのブランチに統合します。
    4.  コンフリクトが発生した場合は解決します。
    5.  再度 `git push origin main` を実行します。今度は Fast-forward なので成功するはずです。

---
## 32.3 `Merge conflict in <file>`

- **エラーメッセージ**: `CONFLICT (content): Merge conflict in <filename>`
- **状況**: `git merge`, `git pull`, `git rebase`, `git cherry-pick` などを実行したとき。
- **原因**: マージしようとしている 2 つのブランチ (またはコミット) で、同じファイルの同じ箇所が異なる内容に変更されており、Git がどちらを優先すべきか自動で判断できない状態です。
- **解決策**:
    1.  `git status` を実行して、コンフリクトが発生しているファイルを確認します。
    2.  コンフリクトしたファイルをエディタで開きます。
    3.  `<<<<<<< HEAD`, `=======`, `>>>>>>>` のようなコンフリクトマーカーを探し、どちらの変更を残すか、あるいは両方をどのように統合するかを判断して、ファイルを**手動で編集**します。最終的にコンフリクトマーカーはすべて削除します。
    4.  編集が完了したら、`git add <filename>` を実行して、コンフリクトが解決したことを Git に伝えます。
    5.  `git commit` (マージの場合) または `git rebase --continue` (リベースの場合) を実行して、プロセスを完了させます。

---
## 32.4 `The following untracked working tree files would be overwritten...`

- **エラーメッセージ**: `error: The following untracked working tree files would be overwritten by checkout: ...`
- **状況**: `git switch`, `git pull` など、作業ディレクトリのファイルを書き換える可能性のあるコマンドを実行したとき。
- **原因**: あなたが新しく作成したり変更したりしたファイルが、まだ Git の追跡対象になっていない (一度も `add` されていない) 状態で、実行しようとしているコマンド (例: `git switch feature-A`) によって、同じ名前のファイルが別の内容で作成されようとしている状態です。Git は、あなたの追跡されていない作業内容が失われるのを防ぐために、コマンドの実行を停止します。
- **解決策**:
    - **そのファイルが必要な場合**: `git add <filename>` と `git commit` を使ってコミットするか、`git stash` を使って一時的に退避させます。
    - **そのファイルが不要な場合**: `rm <filename>` でファイルを削除します。

---
**まとめ**

- Git のエラーメッセージは、リポジトリを破壊から守るための**セーフティネット**である。
- メッセージを注意深く読めば、ほとんどの場合、原因と解決策のヒントが書かれている。
- `detached HEAD`: コミットを直接チェックアウトしている状態。新しいブランチを作る (`git switch -c`) か、既存のブランチに戻る (`git switch main`)。
- `non-fast-forward`: リモートが先に進んでいる。`fetch` してマージ/リベースしてから `push` する。
- `Merge conflict`: 変更が衝突している。手動でファイルを編集し、`add` してからプロセスを続行する。
- `Untracked files would be overwritten`: 追跡されていないファイルが上書きされそうになっている。コミットするか、退避 (`stash`) するか、削除する。
