# 第33章: コミットの修正・取り消し

開発の現場では、コミットした直後にミスに気づくことがよくあります。「メッセージのタイポ」「関連ファイルの入れ忘れ」「デバッグコードの消し忘れ」など、その内容は様々です。

Gitには、このような状況に対処するための3つの主要なコマンド、`git commit --amend`、`git reset`、`git revert`があります。これらはすべて「コミットを修正・取り消す」という目的で使われますが、その動作原理と歴史への影響は全く異なります。

この章では、これらのコマンドを「**そのコミットは、まだあなたしか知らないローカルなものか？ それとも、既にチームに共有されたものか？**」という観点から、使い分けを学びます。

---
## 33.1 `git commit --amend`: 最新のローカルコミットを修正する

`--amend`は「修正する」という意味です。これは、**直前のコミット**に何かを付け加えたり、メッセージを修正したりするためのコマンドです。

**重要な注意点**: `amend`はコミットを「変更」しているのではありません。内部的には、**直前のコミットを取り消し、新しい内容で全く新しいコミットを作り直して置き換えて**います。つまり、これもまた**歴史の書き換え**です。したがって、`git commit --amend`は、**まだ`push`していない、ローカルにある最新のコミットに対してのみ使うべき**です。

**シナリオ: コミットメッセージの修正とファイルの追加**
```bash
# 演習用リポジトリ
git init
echo "Initial content" > file1.txt
git add .
git commit -m "feat: Add file" # タイポあり 'file' -> 'file1'

# 忘れ物を追加
echo "Another file" > file2.txt
git add file2.txt
```
この時点で、メッセージのタイポを修正し、`file2.txt`を先ほどのコミットに含めたくなりました。

**解決策: `--amend`でコミットを置き換える**
```bash
git commit --amend -m "feat: Add file1 and file2"
```
`-m`オプションで新しいメッセージを指定しました。ステージングエリアに`file2.txt`があったため、それも自動的に新しいコミットに含まれます。`git log`を確認すると、タイポのあるコミットは消え、新しいメッセージと内容を持つ1つのコミットだけが存在しています。

---
## 33.2 `git reset`: ローカルの歴史を巻き戻す

`reset`は、ブランチのポインタ (`HEAD`) を過去の特定のコミットに移動させることで、コミットを「なかったことにする」コマンドです。これもまた、歴史を書き換えるため、**`push`していないローカルのコミットに対してのみ使用**します。

`reset`には主に3つのモードがあります。
-   `--soft`: コミットだけを取り消す。変更はステージングエリアに残る。
-   `--mixed` (デフォルト): コミットとステージングを取り消す。変更は作業ディレクトリに残る。
-   `--hard`: コミット、ステージング、作業ディレクトリの変更をすべて取り消す。（危険！）

**シナリオ: 直前のコミット2つをやり直したい**
```bash
git init
echo "C1" > file.txt && git add . && git commit -m "C1"
echo "C2" >> file.txt && git add . && git commit -m "C2"
echo "C3" >> file.txt && git add . && git commit -m "C3"
```
`C2`と`C3`のコミットは、実は1つにまとめるべきでした。

**解決策: `--soft`リセットでコミットを再構成**
```bash
# 2つ前のコミット (C1) の状態まで HEAD を戻す
git reset --soft HEAD~2
```
`git log`を見ると`C1`しかありませんが、`git status`を見ると`C2`と`C3`の変更がステージングされたままになっています。ここから、改めて1つの正しいコミットを作成できます。
```bash
git commit -m "feat: Add C2 and C3 features"
```

---
## 33.3 `git revert`: 共有された歴史を安全に打ち消す

もし、取り消したいコミットが**既に`push`され、チームで共有されている**場合はどうでしょうか？ `amend`や`reset`で歴史を書き換えてしまうと、チームのリポジトリと深刻な矛盾を引き起こします。

このような状況で安全にコミットを打ち消すためのコマンドが`git revert`です。

`revert`は歴史を書き換えるのではありません。**指定したコミットの変更内容を、そっくりそのまま打ち消すような、新しいコミットを作成**します。

**シナリオ: `push`してしまったコミットにバグがあった**
```bash
# リモートとローカルを準備
git init --bare ../shared.git
git clone ../shared.git local && cd local
echo "Good change" > file.txt && git add . && git commit -m "Good change"
echo "This commit has a bug" >> file.txt && git add . && git commit -m "Bad commit"
git push origin main
```
`Bad commit`を`push`した後で、バグがあることに気づきました。

**解決策: `revert`で打ち消しコミットを作成**
```bash
git revert HEAD # 直前のコミット (Bad commit) を打ち消す
```
このコマンドは、`Bad commit`で行った変更（`"This commit has a bug"`という行の追加）を**削除する**という内容の、新しいコミットを作成します。コミットメッセージの編集を求められるので、なぜrevertしたのか理由を記述して保存します。

`git log`を見ると、歴史は以下のようになっています。
```
* <hash3> Revert "Bad commit"
* <hash2> Bad commit
* <hash1> Good change
```
元の`Bad commit`は歴史の事実として残りつつ、その影響は`Revert "Bad commit"`によって打ち消されました。この新しい歴史は、`push`しても誰のリポジトリとも矛盾を起こしません。

---
**まとめ**

| コマンド | 何をするか？ | 主な用途 | 共有された歴史に安全か？ |
| :--- | :--- | :--- | :--- |
| `git commit --amend` | 最新のコミットを**置き換える** | メッセージ修正、ファイルの追加/削除 | **No** (歴史の書き換え) |
| `git reset` | ブランチのポインタを**巻き戻す** | ローカルの連続したコミットを取り消す | **No** (歴史の書き換え) |
| `git revert` | 変更を**打ち消す新しいコミットを作成** | `push`済みのコミットを安全に取り消す | **Yes** (歴史の追加) |

この使い分けをマスターすることが、Gitを安全かつ効果的に利用する鍵です。迷ったら、「**`push`したっけ？**」と自問自答し、「Yes」なら`revert`、「No」なら`amend`か`reset`、と判断するのが良いでしょう。
