# 第 34 章: `git revert` で安全に歴史を打ち消す

前の章で学んだ `git reset` は、ローカルリポジトリの歴史を「なかったこと」にする強力なツールですが、一度チームで共有した (push した) 歴史を書き換えることは、深刻な問題を引き起こすため絶対に避けるべきです (リベースの黄金律)。

では、push してしまったコミットに含まれるバグや不要な変更を、安全に取り消すにはどうすればよいでしょうか？その答えが `git revert` です。

`git revert` は歴史を書き換えるのではなく、**指定したコミットの変更を打ち消す新しいコミットを作成する**ことで、歴史に矛盾なく変更を無効化します。

---
## 34.1 `revert` の仕組み: 逆の変更を加える

`git revert <commit>` を実行すると、Git は以下の操作を自動的に行います。

1.  指定された `<commit>` がどのような変更 (行の追加、削除、修正) を行ったかを計算する。
2.  その変更を**すべて逆に行う**ような変更セットを生成する。(例: 追加された行は削除し、削除された行は元に戻す)
3.  この逆の変更セットを適用した、**新しいコミット**を作成する。

これにより、元のコミットは歴史の中に残り続けますが、その影響は新しく作られた「打ち消しコミット」によって相殺されます。歴史は一直線に進むため、他の開発者のリポジトリと矛盾が生じることがありません。

---
## 34.2 `git revert` の実践

**シナリオ**: リモートリポジトリに push した最新のコミットに、重大なバグが含まれていることが発覚した。すぐにこの変更を無効化したい。

1.  **準備**: リモートリポジトリ (`shared.git`) と、それをクローンしたローカルリポジトリ (`local`) を用意します。

    ```bash
    # ベアリポジトリ (リモートの代わり)
    git init --bare ../shared.git

    # ローカルリポジトリ
    git clone ../shared.git local && cd local

    # 最初のコミット
    echo "This is the initial, stable version." > README.md
    git add .
    git commit -m "feat: Add stable README"
    git push origin main
    ```

2.  **問題のコミットを作成して push する**:

    ```bash
    # バグを含む変更を追加
    echo "!!! THIS CHANGE CONTAINS A BUG !!!" >> README.md
    git add .
    git commit -m "feat: Add a new, but buggy, feature"

    # チームに共有してしまう
    git push origin main
    ```

    この時点で、`main` ブランチの `HEAD` はバグを含んだコミットを指しています。

3.  **`revert` で打ち消しコミットを作成する**:

    取り消したいコミットは `HEAD` なので、`git revert HEAD` を実行します。

    ```bash
    git revert HEAD
    ```

    このコマンドを実行すると、Git は自動的にコミットメッセージを生成し、エディタを開きます。

    ```
    Revert "feat: Add a new, but buggy, feature"

    This reverts commit <buggy-commit-hash>.
    ```

    デフォルトのメッセージで問題なければ、そのままエディタを保存して閉じます。これにより、新しい「打ち消しコミット」が作成されます。

4.  **状態の確認**:

    `git log` で歴史を確認してみましょう。

    ```
    * <hash3>   Revert "feat: Add a new, but buggy, feature"
    * <hash2>   feat: Add a new, but buggy, feature
    * <hash1>   feat: Add stable README
    ```

    元のバグのあるコミット (`<hash2>`) は歴史に残ったままですが、その直後にそれを打ち消すコミット (`<hash3>`) が追加されています。

    `README.md` の中身を確認すると、バグのある行は消え、最初の安定した状態に戻っていることがわかります。

    ```bash
    cat README.md
    # This is the initial, stable version.
    ```

5.  **安全な push**:

    最後に、この打ち消しコミットをリモートリポジトリに push します。これは通常の Fast-forward push なので、問題なく成功します。

    ```bash
    git push origin main
    ```

    これで、チームの共有リポジトリも安全な状態に戻りました。

---
## 34.3 `revert` と `reset` の使い分け

| 特徴           | `git revert <commit>`                                | `git reset --hard <commit>`                                 |
| :------------- | :--------------------------------------------------- | :---------------------------------------------------------- |
| **歴史への影響** | 新しい打ち消しコミットを**追加**する                 | 既存のコミットを**削除**する (歴史の書き換え)               |
| **安全性**     | 共有リポジトリに対して**安全**                       | 共有リポジトリに対して**危険**                              |
| **主な用途**   | `push` 済みのコミットの取り消し                      | `push` 前のローカルなコミットの破棄                         |
| **共同作業**   | 他の開発者に影響を与えない                           | 他の開発者のリポジトリと矛盾を引き起こす                    |

**「このコミット、`push` したっけ？」**

これが、`revert` と `reset` を使い分けるための最も重要な問いです。

- **Yes (`push` した)** → `git revert` を使って、安全に打ち消す。
- **No (`push` していない)** → `git reset` を使って、ローカルの歴史を綺麗に整理する。

---
**まとめ**

- `git revert` は、指定したコミットの変更を打ち消す**新しいコミットを作成する**コマンドである。
- 歴史を書き換えるのではなく追加するため、チームで共有したリポジトリに対して**安全**に使える。
- `push` してしまったコミットのバグなどを取り消す際の標準的な方法である。
- `revert` か `reset` か迷ったら、`push` したかどうかで判断する。
