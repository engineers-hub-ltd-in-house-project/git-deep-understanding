# 第36章: Gitの高度な機能

本書の旅も、いよいよこれが最後の章です。これまでに学んだ知識で、あなたはGitを業務で使いこなすための十分なスキルを身につけました。この章では、日常的に使う頻度は高くないかもしれませんが、特定の困難な状況であなたを助けてくれる、Gitのさらに高度な機能をいくつか紹介します。

これらのツールは、Gitがいかに多機能で、開発者のあらゆるニーズに応えようとしているかを示しています。

---
## 36.1 `git bisect`: バグの原因を自動で特定する

ある機能が、いつの間にか動かなくなっていた。最新のコミットは問題なさそうだし、1週間前は確かに動いていた。この1週間に積まれた50個のコミットのどれがバグを混入させたのか、一つ一つ手動で確認するのは悪夢です。

`git bisect`は、このような状況でバグの原因となったコミットを**自動的に特定**してくれる、非常に強力なデバッグツールです。`bisect`は「二分探索」を意味し、以下の手順で犯人を探し当てます。

1.  `git bisect start`: 二分探索セッションを開始する。
2.  `git bisect bad`: 現在の`HEAD`（バグがある状態）を「悪い」コミットとしてマークする。
3.  `git bisect good <commit>`: バグがなかったことが分かっている過去のコミット（例: 1週間前のコミット）を「良い」コミットとしてマークする。
4.  Gitは、「良い」コミットと「悪い」コミットの中間のコミットを自動的にチェックアウトする。
5.  あなたはその状態でテストを実行し、バグが再現するかどうかをGitに教える。
    -   バグが再現すれば `git bisect bad`
    -   バグが再現しなければ `git bisect good`
6.  Gitは、あなたのフィードバックを元に、調査範囲を半分に絞り込み、また中間のコミットをチェックアウトする。
7.  これを繰り返すと、探索範囲はどんどん半分になり、最終的にGitは「このコミットがバグを最初に混入させた犯人です」と特定してくれます。

50個のコミットも、この方法ならわずか6回程度のテスト（log₂(50) ≒ 5.6）で特定できます。`git bisect`は、あなたのデバッグ時間を劇的に短縮してくれる魔法の杖です。

---
## 36.2 `git stash`: 作業の一時退避

現在のブランチで作業の途中だが、コミットするにはまだ中途半端。しかし、別のブランチで緊急の修正依頼が来てしまった。こんな時、どうしますか？

`git stash`は、まだコミットしていない作業ディレクトリとステージングエリアの変更を、一時的に「隠し場所（stash）」に退避させるためのコマンドです。

```bash
# 作業の途中で変更がある状態
git status # -> "Changes not staged for commit: ..."

# 現在の変更をスタッシュに退避
git stash
# or メッセージ付きで退避
git stash save "Working on feature X"
```
`stash`を実行すると、作業ディレクトリは`HEAD`コミットと同じクリーンな状態に戻ります。これで、あなたは心置きなく別のブランチに移動して緊急の作業を行うことができます。

緊急の作業が終わったら、元のブランチに戻り、退避させていた作業を復元します。
```bash
git switch feature-branch # 元のブランチに戻る

# 最新のスタッシュを取り出して、スタッシュリストから削除
git stash pop

# 最新のスタッシュを取り出すが、リストには残す
git stash apply
```
`git stash list`で退避させた作業の一覧を確認することもできます。

---
## 36.3 `git worktree`: 複数のブランチで同時に作業する

ある機能のビルドやテストには非常に時間がかかるとします。その待ち時間中に、別のブランチの簡単な修正を行いたい場合、通常は`checkout`でブランチを切り替える必要がありますが、それには作業ディレクトリのファイルが書き換わるという重いコストが伴います。

`git worktree`は、**一つのリポジトリから、複数の作業ディレクトリ（ワーキングツリー）を作成する**機能です。それぞれの作業ディレクトリは異なるブランチをチェックアウトした状態にできるため、`checkout`のコストなしに、複数のブランチを並行して作業できます。

```bash
# mainリポジトリのディレクトリで実行
# ../hotfix-worktree という新しいディレクトリを作成し、hotfixブランチをチェックアウト
git worktree add ../hotfix-worktree hotfix
```
これで、`my-project`ディレクトリは`main`ブランチのまま、隣の`hotfix-worktree`ディレクトリでは`hotfix`ブランチの作業を同時に進めることができます。

作業が終われば、`git worktree remove <path>`で作業ディレクトリを削除できます。

---
## 36.4 Git Hooks: 特定のアクションをフックする

Gitは、コミット前 (`pre-commit`)、プッシュ前 (`pre-push`) といった特定のイベントが発生する際に、自動的にスクリプトを実行する**フック (Hooks)** という仕組みを提供しています。

これらは、リポジトリの`.git/hooks`ディレクトリ内に、サフィックスが`.sample`のサンプルスクリプトとして置かれています。この`.sample`を外して実行権限を与えるだけで、フックが有効になります。

例えば、`pre-commit`フックを使えば、
-   コミットするコードが、チームのコーディング規約に準じているかリンターでチェックする。
-   コミットにデバッグコード (`console.log`など) が残っていないかチェックする。
といった品質保証の仕組みを自動化できます。もしスクリプトがエラーで終了すれば、Gitはコミットを中断してくれます。

これにより、人為的なミスを防ぎ、リポジトリの品質を高く保つことができます。

---
**おわりに**

本書『現場で本当に使える Git & GitHub 実践ガイド』は、これにて幕を閉じます。第1部で`.git`の内部を探検することから始まった旅は、日々の基本的な操作、コンフリクトとの戦い、歴史の再構築、そしてチームとの協調作業を経て、この高度なトピックまでたどり着きました。

本書で伝えたかった中心的なメッセージは、「**すべてのGitコマンドは、`.git`ディレクトリ内のオブジェクトと参照を操作しているだけである**」ということです。この基本原則を理解していれば、どんな複雑な状況に遭遇しても、何が起こっているのかを冷静に分析し、次の一手を自信を持って選択できるはずです。

Gitは単なるツールではありません。それは、ソフトウェア開発という複雑な営みを支える、強力な思考のフレームワークです。

この本が、あなたのGitへの恐怖心を自信に変え、日々の開発をより創造的で楽しいものにする一助となったのであれば、著者としてこれにまさる喜びはありません。

Happy Gitting!
