# 第 17 章: マージコンフリクトの原理

Three-way マージは非常に賢い仕組みですが、万能ではありません。Git が「どちらの変更を正とするか自動で判断できない」状況、それが**マージコンフリクト (衝突)** です。

コンフリクトは Git 初心者が最も恐れるものの一つですが、その原理と Git が内部で何をしているかを知れば、恐れるに足りません。コンフリクトはエラーではなく、**「人間の判断が必要ですよ」という Git からの親切なメッセージ**なのです。

---
## 17.1 コンフリクトはいつ起こるのか？

コンフリクトが発生する最も一般的なケースは、Three-way マージにおいて、**2 つのブランチが共通の祖先から同じファイルの同じ箇所を別々の内容に変更した**場合です。

Git はマージベース、`main`、`feature` の 3 者を比較します。
- `main`: 「ここの行を A に変更した」
- `feature`: 「ここの行を B に変更した」

Git は「A と B、どっちが正しいの？ それとも両方取り込むべき？」と判断できません。この曖昧さを解決するのが開発者の役割です。

### コンフリクトを意図的に起こしてみる

百聞は一見に如かず。コンフリクトを発生させて、その状態を観察してみましょう。

```bash
# 実験用ディレクトリを作成して移動
mkdir conflict-practice && cd conflict-practice
git init

# 共通の祖先となるコミット
echo "Hello, world!" > greeting.txt
git add .
git commit -m "Initial greeting"

# featureブランチで変更
git switch -c feature
echo "Hello, feature!" > greeting.txt # 同じ行を変更
git add .
git commit -m "Update greeting for feature"

# mainブランチでも同じ行を別の内容に変更
git switch main
echo "Hello, main!" > greeting.txt # 同じ行を変更
git add .
git commit -m "Update greeting for main"
```
これで準備完了です。`main` と `feature` は、`greeting.txt` の 1 行目をそれぞれ別の内容に書き換えました。

では、運命のマージを実行します。
```bash
git merge feature
```
出力結果:
```
Auto-merging greeting.txt
CONFLICT (content): Merge conflict in greeting.txt
Automatic merge failed; fix conflicts and then commit the result.
```
Git は親切にも「`greeting.txt` でコンフリクトが発生しましたよ。手動で修正してコミットしてくださいね」と教えてくれます。

---
## 17.2 コンフリクト発生時の内部状態

マージに失敗し、コンフリクトが発生したとき、リポジトリは特殊な「マージ中」の状態になります。この時、`.git` ディレクトリとワーキングディレクトリでは何が起こっているのでしょうか。

### ワーキングディレクトリ: コンフリクトマーカー

まず、コンフリクトが発生した `greeting.txt` の中身を見てみましょう。
```
<<<<<<< HEAD
Hello, main!
=======
Hello, feature!
>>>>>>> feature
```
Git は、競合した箇所を**コンフリクトマーカー**で囲んで、ファイルに直接書き込みます。

- `<<<<<<< HEAD`: これから `=======` までは、`HEAD`（つまり現在のブランチ、`main`）での変更内容です。
- `=======`: `main` での変更と `feature` での変更の区切り線です。
- `>>>>>>> feature`: これより上は、マージしようとしたブランチ（`feature`）での変更内容です。

Git は「`main` ではこう変更されていて、`feature` ではこう変更されているけど、どうしますか？」と、両方の選択肢を提示してくれているのです。

### `.git` ディレクトリの内部

この特殊な状態で、`.git` の中も見てみましょう。

1.  **`MERGE_HEAD` ファイル**:
    ```bash
    cat .git/MERGE_HEAD
    ```
    このファイルには、マージしようとしていたブランチ (`feature`) の先端コミットのハッシュが記録されています。このファイルが存在することが、リポジトリが「マージ中」であることを示しています。

2.  **`MERGE_MSG` ファイル**:
    ```bash
    cat .git/MERGE_MSG
    ```
    ここには、コンフリクトが解決した後にコミットする際の、デフォルトのコミットメッセージが格納されています。

3.  **インデックス (`.git/index`) の特殊な状態**:
    これが最も重要です。`git ls-files --stage` コマンドで、インデックスの生の状態を見てみましょう。

    ```bash
    git ls-files --stage
    ```
    出力結果（例）:
    ```
    100644 <blob_hash_1> 1	greeting.txt
    100644 <blob_hash_2> 2	greeting.txt
    100644 <blob_hash_3> 3	greeting.txt
    ```
    通常、ファイルエントリのステージ番号は `0` です。しかしコンフリクト中は、同じファイルに対して **3 つのエントリ** が記録されます。

    - **ステージ 1**: **共通の祖先 (common ancestor)** のバージョン。`Hello, world!` の `blob`。
    - **ステージ 2**: **ターゲットブランチ (`HEAD`, `main`)** のバージョン。`Hello, main!` の `blob`。
    - **ステージ 3**: **マージングブランチ (`feature`)** のバージョン。`Hello, feature!` の `blob`。

    Git はこの 3 つのバージョンをインデックスに保持し、開発者がこれらを元に最終的なバージョン（ステージ 0）を作成し、`git add` することを待っているのです。コンフリクト解決とは、**「インデックス内のステージ 1, 2, 3 のエントリを、解決済みの内容を持つステージ 0 のエントリに置き換える作業」** と言い換えることができます。

---
**まとめ**

この章では、コンフリクトの発生原理と、その際の Git の内部状態を解き明かしました。

- コンフリクトは、2 つのブランチが同じファイルの同じ箇所を別々に変更したときに発生する。
- コンフリクトはエラーではなく、Git が開発者に判断を仰ぐための正常なプロセスである。
- 発生時、ワーキングディレクトリのファイルには、両方の変更を示す**コンフリクトマーカー**が挿入される。
- 内部的には、リポジトリは「マージ中」状態に入り、インデックスには**ステージ 1, 2, 3** という 3 つのバージョンのファイルが記録される。

この内部状態を理解した今、私たちはコンフリクトを解決するための具体的な手順に進む準備ができました。次の章では、この「マージ中」状態を正常な状態に戻すためのステップを学びます。
