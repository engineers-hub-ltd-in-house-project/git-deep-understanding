# 第 2 部: 基本操作を内部から理解する

---

# 第 8 章: `git add` の完全理解

第 1 部で、私たちは `git add` コマンドが以下の 2 つのことを行っていると学びました。

1.  ワーキングディレクトリにあるファイルの中身から `blob` オブジェクトを作成し、`.git/objects` に保存する。
2.  「このファイルパスは、この `blob` オブジェクトを指す」という情報を `.git/index` ファイル（ステージングエリア）に記録・更新する。

この内部的な振る舞いを理解した今、私たちは `git add` を新たな視点で見ることができます。`git add` は、単に「ファイルを追加する」コマンドではありません。それは、**「次のコミットに含めたい変更を選択し、インデックスという設計図を更新する」**ための、より強力で精密なツールなのです。

この章では、`git add` の様々な側面を、第 1 部で得た知識と結びつけながら探求します。

---

## 8.1 `git add` の 3 つの基本パターン

`git add` の使われ方には、大きく分けて 3 つのパターンがあります。「新規追加」「変更のステージング」「削除のステージング」です。それぞれのパターンで、ワーキングディレクトリ、インデックス、そして `objects` データベースがどのように変化するのかを見ていきましょう。

まずは実験の準備です。

```bash
# 実験用ディレクトリを作成して移動
mkdir git-add-practice && cd git-add-practice
git init

# 最初のコミットを作成しておく
echo "Original content" > file.txt
git add file.txt
git commit -m "Add file.txt"

# 現在のインデックスの状態を確認
git ls-files --stage
```

### パターン 1: 新規ファイルの追加

これは最もシンプルなパターンです。

```bash
# 新しいファイルを作成
echo "New file" > new_file.txt

# 新しいファイルをステージング
git add new_file.txt

# インデックスの状態を確認
git ls-files --stage
```
出力結果（例）：
```
100644 120de842e03b20757c3e533e461159a72e81134a 0	file.txt
100644 55dc2df186b208c738e41575836814b7e80ad4f7 0	new_file.txt
```
**内部の動き**:
1.  Git は `new_file.txt` の中身から新しい `blob` オブジェクト（`55dc2...`）を作成します。
2.  `index` ファイルに、`new_file.txt` と新しい `blob` を関連付ける新しい行が追加されます。

### パターン 2: 変更のステージング

次に、既存のファイルを変更して `add` してみましょう。

```bash
# file.txtを編集
echo "Updated content" > file.txt

# 変更をステージング
git add file.txt

# インデックスの状態を確認
git ls-files --stage
```
出力結果（例）：
```
100644 182356026a19c50e2402636c498394208a54e44f 0	file.txt
100644 55dc2df186b208c738e41575836814b7e80ad4f7 0	new_file.txt
```
`file.txt` に対応する `blob` のハッシュ値が、最初のコミット時 (`120de...`) から新しいもの (`18235...`) に変わっている点に注目してください。

**内部の動き**:
1.  Git は `file.txt` の**新しい**中身から、**新しい**`blob` オブジェクト（`18235...`）を作成します。元の `blob` はそのまま残ります。
2.  `index` ファイル内で、`file.txt` に関連付けられていた `blob` のハッシュ値を、新しいハッシュ値で**上書き**します。

### パターン 3: 削除のステージング

ファイルを削除したことを Git に伝える場合も `git add` を使います。（`git rm` コマンドも使えますが、内部的には同じことをしています。）

```bash
# new_file.txt を削除
rm new_file.txt

# 「削除された」という変更をステージング
git add new_file.txt

# インデックスの状態を確認
git ls-files --stage
```
出力結果（例）：
```
100644 182356026a19c50e2402636c498394208a54e44f 0	file.txt
```
`index` から `new_file.txt` のエントリが消えました。

**内部の動き**:
1.  ワーキングディレクトリに `new_file.txt` が存在しないことを検知します。
2.  `index` ファイルから、`new_file.txt` に対応する行を**削除**します。
3.  `blob` オブジェクト自体は `objects` ディレクトリから削除されません。どこからも参照されなくなったオブジェクトは、将来 `git gc`（ガベージコレクション）が実行されるタイミングでクリーンアップされます。

これらの 3 パターンから分かるように、`git add` とは**「現在のワーキングディレクトリの状態をインデックスにコピー（同期）する」**ためのコマンドなのです。

---
## 8.2 コミットを整形する `git add -p`

`git add` が最も輝くのは、ファイル単位ではなく、**変更の塊（hunk）**単位でステージングできる `--patch`（または `-p`）オプションを使う時です。

`file.txt` に 2 つの関連のない変更を加えてみましょう。

```bash
# file.txtに2種類の変更を追加
echo "Function A" >> file.txt
echo "Documentation fix" >> file.txt

# `git diff` で変更内容を確認
git diff
```
diff の出力：
```diff
--- a/file.txt
+++ b/file.txt
@@ -1,1 +1,3 @@
-Updated content
+Updated content
+Function A
+Documentation fix
```
これらの変更を「機能 A の追加」と「ドキュメント修正」という 2 つの別々のコミットにしたい場合、`-p` オプションが役立ちます。

```bash
git add -p file.txt
```

これを実行すると、Git は変更点を塊ごとに表示し、ステージングするかどうかを対話形式で尋ねてきます。

```
Stage this hunk [y,n,q,a,d,/,s,e,?]?
```
ここで `s` (split) を選んで hunk を分割し、`Function A` の変更だけ `y` (yes) を選択してステージングします。その後、`q` (quit) で終了します。

この時点で `git status` を見ると、`file.txt` が「ステージングされた変更」と「ステージングされていない変更」の両方を持っていることが分かります。`git ls-files --stage` でインデックスの中身を見ると、`Function A` までを含んだ内容の `blob` が登録されています。

ここですかさず 1 回目のコミット。
```bash
git commit -m "feat: Add function A"
```

そして、残りの変更を `add` して 2 回目のコミット。
```bash
git add file.txt
git commit -m "fix: Correct documentation"
```

このように、`git add -p` を使うことで、作業の流れで混ざってしまった変更を、意味のある論理的な単位に分割してコミットすることができます。これは、後から履歴を追いやすくするための、非常に重要なテクニックです。

---
**まとめ**

この章では、`git add` を内部構造と結びつけ、その本質を深く理解しました。

-   `git add` は単なる「ファイル追加」ではなく、**「ワーキングディレクトリからインデックスへ、次のコミット内容を選択してコピーする」**コマンドである。
-   新規追加、変更、削除のいずれの操作も、最終的にはインデックスファイルを更新することで実現されている。
-   `git add -p` は、変更を Hunk 単位でステージングできる強力な機能であり、**論理的で綺麗なコミット**を作るために不可欠である。

`git add` をマスターすることは、Git の歴史を意図通りに編纂するための第一歩です。次の章では、インデックスに準備したスナップショットを、リポジトリに永続的な記録として刻む `git commit` の裏側を見ていきます。

最後に実験用ディレクトリを削除しておきましょう。
```bash
cd ..
rm -rf git-add-practice
```
